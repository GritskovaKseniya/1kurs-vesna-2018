Добрый вечер! Высылаю вторую часть 3-го задания.
 
Необходимо разработать программу для поиска толкований слов в словаре Даля.
 
После запуска программы пользователь вводит первые буквы искомого слова и нажимает enter.
Программа в алфавитном порядке выводит первые 10 подходящих слов (слово годится, если начинается с введённых символов) и предлагает ввести + для вывода следующих 10 подходящих слов или новые символы для поиска.
 
Если в процессе вывода очередных 10 результатов станет ясно, что подходящие слова кончились, программа выводит после последнего подходящего слова END и возвращается в режим поиска.
 
Но! Если результатом поиска является ровно одно слово, на экран выводится оно само и статья с толкованием. Далее программа снова переходит в режим поиска.
 
Завершение работы программы происходит после ввода exit.
 
При реализации программы нужно соблюсти следующие требования:
1) Программа должна работать быстро.
2) Необходимо соблюсти принцип разделения логики и интерфейса.
3) Исходные коды должны быть отформатированы и содержать поясняющие комментарии к функциям, структурам данных и прочим важным местам в коде.
 
Требование 1 означает, что подход с просмотром файла при каждом новом запросе не прокатит. Нужно загрузить словарь в память, и не просто одним большим куском текста, а разбить его на отдельные статьи и организовать так, чтобы поиск был быстрым. Здесь уместно вспомнить про сортировку массивов и посмотреть, что такое бинарный поиск.
 
Требование 2 означает, что у Вас должен быть отдельный модуль для работы со словарём и отдельный модуль для реализации логики работы со словарём в консоли.
Модуль словаря ничего не должен знать о консоли - мало ли, завтра мы захотим вместо консольного интерфейса графическое приложение - но как это сделать, если в коде модуля словаря будут обращения к stdin и stdout?
 
 
== Модуль SlovarDalya.h ==
 
Итак, для начала Вам нужен модуль работы со словарём SlovarDalya.h (см. вложение).
 
Первое, что вам нужно сделать при старте программы - загрузить словарь из файла, для чего нужно реализовать функцию LoadDict.
 
Словарь - это набор статей. Каждая статья представлена структурой DictArticle, которая содержит поле word со словом и поле data с его толкованием.
 
Также у нас будет специальный случай - пустая статья как метка конца списка удовлетворяющих запросу статей. Для проверки, что статья пустая, в модуле есть функция IsEmpty(DictArticle a), которая просто должна проверить, что указатель word = 0.
 
Для поиска в словаре по началу слова надо сделать функцию DictSearchIterator SearchDict(char* query).
 
Эта функция не ищет в словаре все подходящие записи, точнее она вообще ничего не ищет. Она просто возвращает объект для последовательного перебора результатов поиска - итератор (структура DictSearchIterator). У итератора можно выпрашивать по одной подходящей статье, но он ленивый - ничего не ищет, пока не попросят следующую статью, а когда попросят, находит её, отдаёт и отдыхает дальше. Но у него хорошая память - он всегда помнит, откуда продолжать поиск, поэтому никогда не возвращает одну и ту же статью дважды. Если же он понимает, что уже вернул все подходящие статьи, то начинает всё время возвращать пустую статью (см. IsEmpty выше).
 
А вот и итератор:
struct DictSearchIterator
{
char* query; // очевидно, итератор должен помнить запрос
 
// Но этого мало - нужны дополнительные поля, но они зависят от реализации,
// т.е. от того, как Вы храните словарь в памяти.
}
 
Для получения следующей подходящей статьи из итератора нужно реализовать функцию
DictArticle NextResult(DictSearchIterator* iter) - она возвращает следующую статью или пустую статью, если больше нет подходящих. Итератор передаётся через указатель для того, чтобы функция могла изменить его внутреннее состояние (он же должен запомнить, что выдал ещё одну запись [помните, что в параметр функции передаётся копия данных, а не сами данные?]).
 
 
Итак, когда вы всё это сделаете, почти вся ЛР готова - останется написать пару процедур для реализации логики работы в консоли.
 
== Про файл словаря ==
 
Словарь дан в виде текстового файла в кодировке OEM866 (такая кодировка позволяет без проблем работать с кириллическими символами по крайней мере в Windows+Code::Blocks 17.12 Portable).
 
Каждой статье соответствует одна строка (символы до \n) файла.
Общий вид строки:
 
СЛОВО1[, СЛОВО2] толкование
 
т.е. толкуемое слово пишется в верхнем регистре, через запятую может быть ещё одно слово с тем же значением (тоже большими буквами), а затем уже следует толкование.
 
Во вложении файл SampleOEM866.txt с вырезкой 100 статей из словаря - этого хватит на первое время для отладки.
 
Отметим, что в словаре может быть несколько статей для одного слова - наверно эти статьи надо объединять в одну, а может как-то иначе - подумайте.
 
 
Во вложении файл main.cpp содержит код для чтения и вывода на экран содержимого этого тестового файла (вот где пригодится функция ReadLongString из первой части задания)
 
P.S. Это первое "сложное" задание, но будут ещё. К следующей паре нужно выполнить 3.1 (ReadLongString), научиться доставать из строки тестового файла толкуемые слова (СЛОВО1, СЛОВО2) и само толкование, а также подумать, как организовать хранение словаря на памяти так, чтобы поиск был быстрым.