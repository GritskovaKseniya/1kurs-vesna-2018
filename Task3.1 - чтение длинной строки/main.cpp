#include <cstdio>
#include <cstring>
#include <clocale>


/// Читает строку любой длины из потока, пока не встретит перевод строки \n.
/// Возвращает строку в динамической памяти с прочитанными данными (\n в конце строки есть).
char* ReadLongString(FILE* str)
{
    // Начальный размер буфера. Будет увеличиваться в 2 раза на каждой итерации
    // В целях отладки надо сначала делать маленьким, а потом можно сделать побольше
    int size = 3;

    // Буфер
    char* buf = new char[size];

    // Место в буфере, начиная с которого пишем новые данные. Изначально начало буфера
    char* readStart = buf;

    // Метка конца буфера. Если её перетёрли в 0, то буфер был заполнен полностью.
    buf[size-1] = 123;

    while(true)
    {
        // Читаем символы в буфер - не более, чем осталось байт от readStart до конца буфера
        fgets(readStart, (size - (readStart - buf)), str);


        // Разбираемся, всё ли прочитано или надо будет ещё прочитать.
        if((buf[size -1] == 123) || (buf[size - 2] == '\n'))
        /*если последний элемент равен метке конца, то строка короткая и данные прочитаны
        если предпоследний символ - перевод строки, то строчка вместилась ровно*/
        {
            // Если метку не тронули, то строка короткая и уже прочитана.
            // Если перетёрли, но предпоследний символ - перевод строки, то строка вместилась в тютельку
            return buf;

        }

        char* bufOld = buf; //создаем временную переменную для передачи данных
        buf = new char[size * 2]; //выделяем память в куче в два раза большего объёма
        strcpy(buf, bufOld);//копируем данные
        delete[] bufOld;//удаляем ненужнуюю временную память, старый буфер

        readStart = buf + size - 1; // записываем данные с середины буфера, минус один, т.к. 0 занимает ячейку памяти
        size *= 2;// увеличиваем размер памяти

        // Ставим в конце нового буфера метку конца
        buf[size-1] = 123;
    }

}

int main()
{
    //setlocale(LC_ALL, "Russian"); // только ломает
    printf("Input long string\n");

    // Читаем строчку с консоли
    char* s = ReadLongString(stdin);

    // Выводим. Длинна будет всегда на единицу больше визуальной, т.к. в строке будет перевод строки \n
    printf("Readed: %s\nLength=%d\n", s, strlen(s));

    // Сохраняем в файл - можно даже кириллицу набирать
    // но смотреть такой файло надо будет в Notepad++ --> Кодировки --> Кириллица --> OEM866
    printf("Saving it to file file.txt (encoding OEM866)\n");
    FILE* out = fopen("file.txt", "w");
    // в функцию передаётся void* указатель, поэтому вторым параметром (1) мы говорим, сколько байт занимает один элемент массива
    fwrite(s, 1, strlen(s), out);
    // Не забываем закрыть файл!
    fclose(out);

    // Удаляем строку из кучи
    delete[] s;

    printf("Load it from file.txt\n");

    // Читаем файл
    FILE* in = fopen("file.txt", "r");
    char* s2 = ReadLongString(in);
    fclose(in);

    printf("Read from file: %s", s2);

    // Не забываем освободить память
    delete[] s2;

    return 0;
}


