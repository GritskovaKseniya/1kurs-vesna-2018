Добрый день!
 
Высылаю первую часть третьего задания по программированию.
 
На последнем занятии мы с вами рассмотрели, как устроены строки в C. В отличие от простых типов данных наподобие int, для строки в общем случае нельзя заранее выделить достаточное количество памяти. Потенциально они могут занимать сколько угодно памяти. Это опасный момент при чтении строки с клавиатуры или из файла, т.к. можно выйти за границы буфера и сломать программу.
 
Однако (как вы уже знаете или скоро узнаете), все современные языки программирования (и C++ тоже) имеют тип данных "строка" и никаких проблем с чтением строки любой длины нет. Как же это работает?
 
С базовыми идеями этого механизма Вам и надо разобраться в рамках этого задания.
 
Реализуйте функцию char* ReadLongString(FILE* stream), которая читает из потока stream строку любой длины, пока не встретит перевод строки \n (=пользователь нажал enter) и возвращает указатель на массив с данными в куче (следовательно пользователь функции должен не забыть освободить эту память, когда она ему больше не нужна).
 
При реализации вам понадобятся:
* динамическое выделение памяти new, delete
* копирование строк (<cstring>: функция strcpy)
* виртуозное владение указателями
* функция fgets из модуля ввода-вывода языка C <cstdio>, которая читает из потока не более, чем заданное количество символов.
 
На лекции мы с вами поближе познакомились с модулем ввода-вывода языка C <cstdio> и функцией fgets
 
Поток - это удобная абстракция для взаимодействия с консолью, файлами и др. Идея проста - у нас есть очередь символов (байт): с одной стороны в неё символы приходят, а с другой их кто-то забирает.
В случае чтения данных с клавиатуры мы используем поток stdin и забираем символы из него, а кладёт символы туда пользователь. При выводе на экран - наоборот - мы кладём туда символы, а система забирает и отображает на экране.
 
В <cstdio> есть стандартные потоки stdin для чтения с клавиатуры и stdout для вывода данных в консоль, но легко создавать потоки, связанные с файлами, при помощи функции fopen().
 
Итак, функция fgets(char* buf, int maxNum, FILE* stream) - из потока stream в буфер buf читает символы, пока не встретит перевод строки \n либо не прочитает maxNum-1 символов. Далее она дописывает признак конца строки (нулевой байт) и завершает работу.
 
Во вложении файл с функцией main и зарубками по реализации ReadLongString() - Вам необходимо только дописать недостающие части.
 
В main приведён пример работы с файлами (в частности с кириллическими символами), что понадобится для второй части работы.
 
 
NB! В случаях, когда в C и C++ есть средства для решения одних и тех же задач (ввод-вывод, динамическое выделение памяти), пользоваться следует чем-то одним и не смешивать. Дело в том, что эти модули ничего друг о друге не знают и никак не синхронизируются.
 
Например делать new, а потом free - безсмысленно, т.к. free ничего не знает о блоке памяти, выделенном new и может вообще считает его свободным (хуже, если так посчитает malloc). Аналогично не рекомендуется смешивать в одной программе использование <iostream> и <cstdio>.
 
 
Доп. задание.
 
Изучите функцию realloc() из модуля <cstdlib>. Чем она может пригодиться? Будет ли реализация функции ReadLongString() эффективнее?