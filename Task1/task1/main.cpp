#include <iostream>

using namespace std;

void setPointer (int k){
    cout<<"Вход в функцию"<<endl;
    int* pa=&k;//берем указатель на параметр
    cout<<"адрес переменной k: "<<pa<<endl;
    cout<<"k= "<<k<<endl;//выводим значение параметра
    k=10;//даем ему новое значение
    cout<<"k= "<<k<<endl;//выводим его
    cout<<"Выход из функции"<<endl;
}

int* getPointer(int value){
    int a=value;//берем переменную
    int* pa=&a;//берем указатель на адрес переменной
    return pa;
}


int main()
{
    setlocale(0, "");
    cout<<"Задание 1.1:\n";
    int k(9);//берем переменную к=9
    int* pk=&k;//берем указатель на адрес переменной к
    cout<<"адрес переменной k: "<<pk<<endl;
    setPointer(k);// передаем переменную к в качестве параметра функции
    cout<<"k= "<<k<<endl<<endl<<endl;/*проверяем значение переменной k после вызова функции.
     У нас вывелось k=9, но в функции мы меняли значение k=10.*/

    /*Следовательно получили, что переменная k (из main) и k (из setPointer) это 2 разные переменные. т.к. адреса у них тоже разные*/

    cout<<"Задание 1.2:\n";
    cout<<"Значение по адресу после первого вызова функции: ";
    int* a=getPointer(0);
    cout<<*a<<endl;
    cout<<"Значение по такому же адресу после второго вызова функции: ";
    getPointer(1);//меняем значение a в функции
    cout<<*a<<endl;
    /*
    В итоге получили, что после того как мы вызвали функцию второй раз, под переменную a выделилась таже область памяти, которая была выделена под переменную из первого вызова функции.
    Но система может выделить память под переменную, если эта область пуста, а значит переменная которая лежала в этой области памяти стерлась.
    Это означает, что переменная a существует только во время выполнения блока, в котором она объявлена.
    */

    return 0;
}
